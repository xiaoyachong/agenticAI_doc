# What is MCP?

MCP (Model Context Protocol) is an open standard created by Anthropic (announced November 2024) for connecting AI assistants to external data sources and tools.

## Official Description:

> "MCP is an open protocol that standardizes how applications provide context to LLMs. Think of it as a USB-C port for AI applications - one standard, many uses."

## Key Characteristics:

```
┌─────────────┐                    ┌─────────────┐
│   AI Host   │ ←── MCP Protocol ──→│ MCP Server  │
│  (Claude,   │                    │  (Data/Tool │
│   ChatGPT)  │                    │   Provider) │
└─────────────┘                    └─────────────┘
```

**Communication:** 
- **Protocol:** JSON-RPC over stdio, SSE (Server-Sent Events), or WebSockets
- **NOT HTTP REST** - It's a specialized protocol
- **NOT message queue** - It's request/response with streaming

---

## MCP Architecture

### Example from Anthropic's docs:

```
┌──────────────────────────────────────────┐
│         Claude Desktop App               │
│  (MCP Host/Client)                       │
└───────────┬──────────────────────────────┘
            │ MCP Protocol
            │
    ┌───────┼────────┬─────────────┐
    │       │        │             │
    ▼       ▼        ▼             ▼
┌────────┐ ┌──────┐ ┌──────────┐ ┌──────┐
│Postgres│ │GitHub│ │ Filesystem│ │Slack │
│ Server │ │Server│ │   Server  │ │Server│
└────────┘ └──────┘ └──────────┘ └──────┘
 (MCP      (MCP     (MCP         (MCP
  Server)   Server)  Server)      Server)
```

### MCP Server Structure:

```typescript
// Example MCP Server
import { Server } from "@modelcontextprotocol/sdk/server/index.js";

const server = new Server({
  name: "example-server",
  version: "1.0.0"
});

// Define tools (like capabilities)
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: "get_weather",
      description: "Get weather for a location",
      inputSchema: { ... }
    }
  ]
}));

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === "get_weather") {
    return { content: [ { type: "text", text: "Sunny, 72°F" } ] };
  }
});
```

---

## MCP vs Your HTTP Approach

### MCP Architecture:
```
Framework (MCP Client)
    ↓ JSON-RPC over SSE/WebSocket
Agent (MCP Server)
    - Defines tools/resources
    - Responds to requests
    - Can push updates (SSE)
```

### Your HTTP Approach:
```
Framework (HTTP Client)
    ↓ REST API
Agent (HTTP Server)
    - Defines capabilities
    - Responds to requests
    - Stateless
```

### Detailed Comparison:

| Feature | MCP | Your HTTP Approach |
|---------|-----|-------------------|
| **Protocol** | JSON-RPC over SSE/stdio | REST over HTTP |
| **Transport** | SSE, WebSocket, stdio | HTTP POST/GET |
| **Standard** | Anthropic's open protocol | Generic REST API |
| **Tool Discovery** | Built-in `tools/list` | Your custom `/capabilities` |
| **Streaming** | ✅ Built-in (SSE) | ❌ (would need Server-Sent Events) |
| **State** | Can maintain connection | Stateless |
| **SDK** | Official TypeScript/Python SDKs | You write your own |
| **Adoption** | New (Nov 2024), growing | Universal (decades old) |
| **Complexity** | More complex protocol | Simpler REST |
| **Ecosystem** | Growing (Claude, Zed, others) | Massive (everything uses HTTP) |

---

## Is MCP Message-Based?

**No, MCP is NOT message-based** (like RabbitMQ/Kafka).

**MCP is:**
- ✅ Request/response protocol (like HTTP)
- ✅ Can stream responses (SSE)
- ✅ Persistent connection (optional)
- ❌ NOT asynchronous message queue
- ❌ NOT pub/sub

**Think of it as:** "HTTP but specialized for AI tool calling"

---

## Should You Use MCP for Framework ↔ Agent Communication?

### Short Answer: **Probably NOT** (for your internal architecture)

### Why NOT MCP for Internal Communication:

#### 1. **MCP is designed for AI ↔ Tool, not Framework ↔ Agent**

**MCP's intended use:**
```
Claude Desktop ←MCP→ Your Tool/Data Source
     (AI)              (External service)
```

**Your architecture:**
```
Framework ←?→ Agent
(Orchestrator)  (Contains AI capabilities)
```

You need orchestration protocol, not tool protocol.

#### 2. **MCP is more complex than you need**

```python
# MCP requires:
- JSON-RPC protocol implementation
- SSE or WebSocket handling
- Schema validation (JSON Schema)
- SDK integration

# HTTP needs:
- Simple POST request
- JSON payload
- That's it!
```

#### 3. **MCP is overkill for internal services**

**MCP adds:**
- Protocol overhead
- SDK dependencies
- More complexity
- Steeper learning curve

**Your HTTP approach gives you:**
- Simplicity
- Universal tools (curl, Postman)
- Easy debugging
- Everyone knows HTTP

---

## Where MCP WOULD Make Sense

### Use Case 1: Agents expose tools TO external AI clients

If you want **external users** to use Claude Desktop or other MCP clients to talk to your agents:

```
Claude Desktop (MCP Client)
    ↓ MCP Protocol
    ↓
Beamline Agent (MCP Server)
    - Exposes motor_control as MCP tool
    - External users can control via Claude Desktop
```

**Example:**
```python
# beamline-agent as MCP Server
from mcp.server import Server

server = Server("beamline-531")

@server.tool()
async def motor_control(motor_name: str, position: float):
    """Control a beamline motor"""
    # Your motor control logic
    return {"success": True, "position": position}
```

**User experience:**
```
User in Claude Desktop:
"Move motor M1 to 45 degrees"
    → Claude calls your MCP server
    → Motor moves
    → Claude responds: "Motor moved!"
```

### Use Case 2: Framework uses MCP to call external tools

If your framework needs to call **external MCP servers** (not your agents):

```
Your Framework
    ↓ MCP Protocol
    ↓
External MCP Servers:
    - GitHub MCP Server
    - Slack MCP Server  
    - Google Drive MCP Server
```

This is like using the **MCP ecosystem** for external integrations.

---

## Recommended Architecture for You

### Hybrid Approach:

```
┌─────────────────────────────────────────────┐
│          Your Framework                     │
│  ┌────────────────────────────────────┐    │
│  │   LangGraph Orchestration          │    │
│  └────────┬──────────────────┬────────┘    │
│           │                  │              │
│           │ HTTP (internal)  │ MCP (external)
│           │                  │              │
└───────────┼──────────────────┼──────────────┘
            │                  │
            │                  └──────────────────┐
            │                                     │
    ┌───────▼────────┐                    ┌──────▼─────────┐
    │ Your Beamline  │                    │ External MCP   │
    │ Agents         │                    │ Servers        │
    │ (HTTP API)     │                    │ (GitHub, etc.) │
    └────────────────┘                    └────────────────┘
```

**Internal (Framework ↔ Agents):** Keep your HTTP approach ✅
- Simpler
- You control both sides
- Easy to debug
- Works perfectly

**External (Framework ↔ Tools):** Consider MCP 🤔
- Access MCP ecosystem
- Standard protocol
- Growing adoption
- But optional

---

## Real-World Example: How Others Use MCP

### Anthropic Claude Desktop:

Uses MCP to connect to external tools:

```typescript
// Claude Desktop config (~/.claude/config.json)
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/Users/you/Desktop"]
    },
    "github": {
      "command": "npx", 
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "..."
      }
    }
  }
}
```

Now Claude Desktop can:
- Read/write files (via filesystem MCP server)
- Access GitHub repos (via github MCP server)

**But internally, Anthropic's infrastructure:**
- Likely uses gRPC/HTTP microservices, NOT MCP!
- MCP is for AI ↔ Tools, not Service ↔ Service.

---

## Your PV Finder Agent MCP Example

I see you already explored MCP! From your project knowledge:

```python
# services/applications/als_assistant/pv_finder/
# This is an MCP Server that exposes PV finding to MCP clients
```

**This is GREAT for:**
- ✅ External users accessing via Claude Desktop
- ✅ Testing agents via MCP clients  
- ✅ Providing standard interface

**But for Framework ↔ Agent:**
- ⚠️ Framework would need to be an MCP client
- ⚠️ More complex than HTTP
- ⚠️ Harder to test (need MCP client tools)

---

## My Recommendation

### Keep Your Current HTTP Approach ✅

**For internal communication (Framework ↔ Agents):**

```python
# Simple, clean, works perfectly
await http_client.post(
    f"{agent_url}/capability/motor_control",
    json={"motor_name": "M1", "position": 45}
)
```

### Add MCP as Optional Interface 🎯

**For external access (Users ↔ Agents):**

Each agent can **ALSO** expose an MCP interface:

```
Beamline Agent
├── HTTP API (for framework) ← Primary
└── MCP Server (for external users) ← Optional bonus
```

### Example: Dual Interface Agent

```python
# src/agent/server.py

# HTTP Server (for framework)
@app.post("/capability/motor_control")
async def motor_control_http(request: CapabilityRequest):
    result = await execute_motor_control(request.parameters)
    return {"success": True, "result": result}

# MCP Server (for external users)  
from mcp.server import Server
mcp_server = Server("beamline-531")

@mcp_server.tool()
async def motor_control(motor_name: str, position: float):
    """Control a beamline motor via MCP"""
    result = await execute_motor_control({
        "motor_name": motor_name,
        "position": position
    })
    return result

# Run both servers
# HTTP on port 8053 (framework)
# MCP on stdio (external users)
```

---

## Bottom Line

### MCP is:
- ✅ A new standard protocol (Anthropic, Nov 2024)
- ✅ For connecting AI to tools/data
- ✅ Growing ecosystem
- ❌ NOT message-based (it's request/response)
- ❌ NOT a replacement for your HTTP approach

### Should you use MCP?

**Between Framework ↔ Agents: NO ❌**
- HTTP is simpler
- HTTP is universal
- You control both sides
- Easier to debug

**For External Access: MAYBE 🤔**
- Nice to have
- Provides standard interface
- Optional bonus feature
- Not critical for MVP

### Your Current Plan (HTTP) is CORRECT ✅

Keep it! You're using the right tool for the job.

MCP is cool, but it's solving a different problem than yours. Your HTTP-based architecture is:
- ✅ Simpler
- ✅ More appropriate
- ✅ Industry standard for microservices
- ✅ What OpenAI, AutoGPT, and others use

Don't change your architecture to use MCP. Consider MCP only as an optional external interface layer if needed later.